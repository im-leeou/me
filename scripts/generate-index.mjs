import { GENERATED_INDEX_FOLDERS } from './_config-generate.mjs';

import fs from 'fs';

class GenerateIndexExports {
  #keepNames = ['.gitkeep'];
  #dumpNames = ['.DS_Store'];
  #excludedNames = [
    ...this.#keepNames,
    ...this.#dumpNames,
    'index.ts',
    'index.tsx',
    '.test.ts',
    '.test.tsx',
    '__tests__',
    '.scss',
    '.stories.tsx'
  ];

  #note = `/**\n* ! This file is auto-generated by run "npm run up-to-date:index"; DO NOT EDIT.\n*/\n`;
  #notFoundComponentAssetPrefix = 'Other';
  #componentAssetPrefix = {
    i: 'Icon',
    lt: 'AmtData'
  };

  #isEmptyFolder(relativePath) {
    const files = fs.readdirSync(relativePath);

    const nonNecessaryFiles = files.filter((fileName) =>
      [...this.#keepNames].includes(fileName)
    );

    if (files.length === 0 || nonNecessaryFiles.length > 0) {
      console.log(`Empty folder: ${relativePath}`);

      return true;
    }

    return false;
  }

  #normalizedFileInfo(filename) {
    const [name, ext] = filename.split('.');

    return {
      name,
      ext
    };
  }

  #formatComponentName(name) {
    const prefixKey = name.split('-')[0];

    let prefix = this.#notFoundComponentAssetPrefix;

    const ComponentPrefix = this.#componentAssetPrefix[prefixKey];
    if (ComponentPrefix) {
      prefix = ComponentPrefix;
    }

    const removedPrefixKey = name.replace(`${prefixKey}`, '');

    const camelCasedFilename = removedPrefixKey.replaceAll(
      /-./g,
      (replacedStr) => replacedStr[1].toUpperCase()
    );

    return `${prefix}${camelCasedFilename}`;
  }

  #generateExportLine({ type, data }) {
    switch (type) {
      case '*':
        return `export * from './${data.name}';\n`;
      case 'default-as':
        return `export { default as ${this.#formatComponentName(data.name)} } from './${data.filename}';\n`;
      default:
        console.log(`Invalid export type: ${type}`);
        return null;
    }
  }

  createIndexFile({ relativePath, deep, type, ext }) {
    if (this.#isEmptyFolder(relativePath)) {
      return;
    }

    const foundObjects = fs.readdirSync(relativePath);

    const foundedFolderDirectories = [];
    const exportLines = [];

    foundObjects.forEach((filename) => {
      const stats = fs.statSync(`${relativePath}/${filename}`);

      if (this.#excludedNames.includes(filename)) {
        return;
      }

      if (stats.isDirectory() && deep === 2) {
        foundedFolderDirectories.push(filename);
      }

      if (
        stats.isDirectory() &&
        this.#isEmptyFolder(`${relativePath}/${filename}`)
      ) {
        return;
      }

      const { name, ext } = this.#normalizedFileInfo(filename);

      const generatedExportLine = this.#generateExportLine({
        type,
        data: { name, filename, ext }
      });

      if (!generatedExportLine) {
        return;
      }

      exportLines.push(generatedExportLine);
    });

    const content = `${this.#note}${exportLines.join('')}`;
    fs.writeFileSync(`${relativePath}/index.${ext}`, content);

    console.log(`Generated: ${relativePath}`);

    foundedFolderDirectories.forEach((folder) => {
      const folderPath = `${relativePath}/${folder}`;

      this.createIndexFile({
        relativePath: folderPath,
        deep: deep - 1,
        type,
        ext
      });
    });
  }
}

const generator = new GenerateIndexExports();

GENERATED_INDEX_FOLDERS.forEach((props) => generator.createIndexFile(props));
